#pragma once
#include <d3dx9math.h>
#include <vector>

#define GRAV_ACCEL	981.0f

#define HALF_SQRT_2	0.7071068f
#define BLOCK_SIZE_X 16
#define BLOCK_SIZE_Y 16
class GpuFftPS;
struct CBakeInfo
{
	float			fCycleTime;
	float			fLength;
	unsigned int	iDimension;
	float           fMaxOmega;
	float           fMinOmega;
	float			wave_amplitude;
	D3DXVECTOR2		wind_dir;
	float			wind_speed;
	float			choppy_scale;
	float			wind_dependency;
	float			time_scale;
	float           FPS;
	int             bakeNum;
};

struct CCycleOmega
{
	float fMaxCycle;
	float fMinCycle;
	float fMaxOmega;
	float fMinOmega;
};

class COceanSimulator
{
public:
	COceanSimulator(CBakeInfo &info):m_tBakeInfo(info)
	{
		for (int i = 0; i < 3; ++i)
		{
			MaxDxyz[i] = MaxGradientFold[i] = 1.40129846432481707e-45;
			MinDxyz[i] = MinGradientFold[i] = 3.40282346638528860e+38;
		}
	}
	~COceanSimulator()
	{
		ClearSave();
		SAFE_RELEASE(m_pSRV_H0);
		SAFE_RELEASE(m_pUAV_H0);
		SAFE_RELEASE(m_pBuffer_Float2_H0);

		SAFE_RELEASE(m_pSRV_Omega);
		SAFE_RELEASE(m_pUAV_Omega);
		SAFE_RELEASE(m_pBuffer_Float_Omega);
		
		SAFE_RELEASE(m_pSRV_Ht);
		SAFE_RELEASE(m_pUAV_Ht);
		SAFE_RELEASE(m_pBuffer_Float2_Ht);

		SAFE_RELEASE(m_pImmutableCB);
		SAFE_RELEASE(m_pPerFrameCB);
		SAFE_RELEASE(m_pUpdateSpectrumCS);

		SAFE_RELEASE(m_pQuadVS);
		SAFE_RELEASE(m_pQuadLayout);
		SAFE_RELEASE(m_pQuadVB);
		SAFE_RELEASE(m_pUpdateDisplacementPS);
		SAFE_RELEASE(m_pGenGradientFoldingPS);

		SAFE_RELEASE(InverRealRTV);
		SAFE_RELEASE(InverRealSRV);
		SAFE_RELEASE(InverRealMap);

		SAFE_RELEASE(InverImagRTV);
		SAFE_RELEASE(InverImagSRV);
		SAFE_RELEASE(InverImagMap);

		SAFE_RELEASE(m_pDisplacementRTV);
		SAFE_RELEASE(m_pDisplacementSRV);
		SAFE_RELEASE(m_pDisplacementRTV);

		SAFE_RELEASE(m_pGradientRTV);
		SAFE_RELEASE(m_pGradientSRV);
		SAFE_RELEASE(m_pGradientMap);

		SAFE_RELEASE(m_pNormalRTV);
		SAFE_RELEASE(m_pNormalSRV);
		SAFE_RELEASE(m_pNormalMap);

		SAFE_RELEASE(m_pPointSamplerState);


		SAFE_RELEASE(ReadDisplacementMap);
		SAFE_RELEASE(ReadGradientMap);
	
		SAFE_RELEASE(SaveToFileDisplacementMap);
		SAFE_RELEASE(SaveToFileGradientMap);

		SAFE_DELETE(fft);
	}
	void Init();
	void InitHeightMap( D3DXVECTOR2* out_h0, float* out_omega);
	void SetMaxOmega(float Omega) { m_tBakeInfo.fMaxOmega = Omega; }
	void SetCycle(float Cycle) { m_tBakeInfo.fCycleTime = Cycle; }
	void SetFPS(float FPS) { m_tBakeInfo.FPS = FPS; }
	float ComputeCycleAndOmega();
	void updateDisplacementMap(float time);
	static void CalulerCycleAndOmega(float &Length, unsigned int &Dimension, float &time_scale, CCycleOmega &CycleOmega);
	CBakeInfo m_tBakeInfo;
	GpuFftPS  *fft;
	void COceanSimulator::EncodeImge(std::vector<float*> &saveImge, std::vector<unsigned char*> &EncodeImgefloat, std::vector<unsigned char*> &ErrorImgefloat, float &LogScale, float &MinValue);
	void EncodeImge(std::vector<float*> &saveImge , std::vector<unsigned char*> &EncodeImge, float &LogScale, float &MinValue);
public:
	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	ID3D11Buffer* m_pBuffer_Float2_H0;
	ID3D11UnorderedAccessView* m_pUAV_H0;
	ID3D11ShaderResourceView* m_pSRV_H0;

	// Angular frequency
	ID3D11Buffer* m_pBuffer_Float_Omega;
	ID3D11UnorderedAccessView* m_pUAV_Omega;
	ID3D11ShaderResourceView* m_pSRV_Omega;


	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	ID3D11Buffer* m_pBuffer_Float2_Ht;
	ID3D11UnorderedAccessView* m_pUAV_Ht;
	ID3D11ShaderResourceView* m_pSRV_Ht;

	ID3D11Buffer* m_pImmutableCB;
	ID3D11Buffer* m_pPerFrameCB;

	// Shaders, layouts and constants
	ID3D11ComputeShader* m_pUpdateSpectrumCS;

	ID3D11VertexShader* m_pQuadVS;
	ID3D11InputLayout* m_pQuadLayout;
	ID3D11Buffer* m_pQuadVB;
	ID3D11PixelShader* m_pUpdateDisplacementPS;
	ID3D11PixelShader* m_pGenGradientFoldingPS;



	ID3D11Texture2D* InverRealMap;		// (RGBA32F)
	ID3D11ShaderResourceView* InverRealSRV;
	ID3D11RenderTargetView* InverRealRTV;

	ID3D11Texture2D* InverImagMap;		// (RGBA32F)
	ID3D11ShaderResourceView* InverImagSRV;
	ID3D11RenderTargetView* InverImagRTV;

	// Displacement map
	ID3D11Texture2D* m_pDisplacementMap;		// (RGBA32F)
	ID3D11ShaderResourceView* m_pDisplacementSRV;
	ID3D11RenderTargetView* m_pDisplacementRTV;

	// Gradient field
	ID3D11Texture2D* m_pGradientMap;			// (RGBA16F)
	ID3D11ShaderResourceView* m_pGradientSRV;
	ID3D11RenderTargetView* m_pGradientRTV;

	// Gradient field
	ID3D11Texture2D* m_pNormalMap;			// (RGBA16F)
	ID3D11ShaderResourceView* m_pNormalSRV;
	ID3D11RenderTargetView* m_pNormalRTV;

	// Samplers
	ID3D11SamplerState* m_pPointSamplerState;

	ID3D11Texture2D* ReadDisplacementMap;
	ID3D11Texture2D* ReadGradientMap;


	ID3D11Texture2D* SaveToFileDisplacementMap;
	ID3D11Texture2D* SaveToFileGradientMap;

	float MaxDxyz[3];
	float MinDxyz[3];
	float MaxGradientFold[3];
	float MinGradientFold[3];

	std::vector<float*> saveDisplacement;
	std::vector<float*> saveGradien;

	std::vector<unsigned char*> DisplacementImage;
	std::vector<unsigned char*> GradienImage;
	std::vector<unsigned char*> GradienErrorImage;
	void ClearSave()
	{
		for (float *&i : saveDisplacement)
		{
			if (i)
			{
				delete[] i;
				i = NULL;
			}
		}
		saveDisplacement.clear();
		for (float *&i : saveGradien)
		{
			if (i)
			{
				delete[] i;
				i = NULL;
			}
		}
		saveGradien.clear();

		for (unsigned char *&i : DisplacementImage)
		{
			if (i)
			{
				delete[] i;
				i = NULL;
			}
		}
		DisplacementImage.clear();
		for (unsigned char *&i : GradienImage)
		{
			if (i)
			{
				delete[] i;
				i = NULL;
			}
		}
		GradienImage.clear();
		
		for(unsigned char *&i : GradienErrorImage)
		{
			if (i)
			{
				delete[] i;
				i = NULL;
			}
		}
		GradienErrorImage.clear();
	}

	void SetName(WCHAR *name) {
		wcscpy_s(this->name,128, name
		);
	}
	int cutframe;
	float cuttime;
	WCHAR name[128];
};